#!/usr/bin/env python3
"""
Australian Cyber Events Dashboard Generator

This script generates a complete HTML business intelligence dashboard based on
the specifications in ./specifications/dashboard_specifications.md.

The script creates:
1. A Flask API server with SQLite database integration
2. HTML dashboard with Chart.js visualizations
3. Responsive design with interactive features
4. Export functionality and accessibility compliance

Usage:
    python generate_dashboard.py [--port 5000] [--debug] [--db-path path/to/db]
"""

import argparse
import json
import sqlite3
import os
import sys
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path

try:
    from flask import Flask, jsonify, request, render_template_string, send_from_directory
    from flask_cors import CORS
except ImportError:
    print("Error: Flask is required. Install with: pip install flask flask-cors")
    sys.exit(1)


class DashboardDataService:
    """Service class for fetching dashboard data from SQLite database."""

    def __init__(self, db_path: str):
        self.db_path = db_path

    def _get_connection(self) -> sqlite3.Connection:
        """Get database connection with proper configuration."""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row  # Enable column access by name
        return conn

    def get_monthly_event_counts(self, start_date: str = None, end_date: str = None) -> Dict[str, Any]:
        """Get monthly unique event counts."""
        query = """
        SELECT
            strftime('%Y-%m', event_date) as month,
            COUNT(DISTINCT deduplicated_event_id) as unique_events
        FROM DeduplicatedEvents
        WHERE status = 'Active'
        """
        params = []

        if start_date:
            query += " AND event_date >= ?"
            params.append(start_date)
        if end_date:
            query += " AND event_date <= ?"
            params.append(end_date)

        query += """
        GROUP BY strftime('%Y-%m', event_date)
        ORDER BY month
        """

        try:
            with self._get_connection() as conn:
                cursor = conn.execute(query, params)
                rows = cursor.fetchall()

                months = [row['month'] for row in rows if row['month']]
                counts = [row['unique_events'] for row in rows if row['month']]

                return {
                    'months': months,
                    'counts': counts,
                    'total_events': sum(counts),
                    'avg_per_month': sum(counts) / len(counts) if counts else 0
                }
        except Exception as e:
            print(f"Error fetching monthly event counts: {e}")
            return {'months': [], 'counts': [], 'total_events': 0, 'avg_per_month': 0}

    def get_monthly_severity_trends(self, start_date: str = None, end_date: str = None) -> Dict[str, Any]:
        """Get monthly severity distribution trends."""
        query = """
        SELECT
            strftime('%Y-%m', event_date) as month,
            severity,
            COUNT(DISTINCT deduplicated_event_id) as event_count
        FROM DeduplicatedEvents
        WHERE status = 'Active'
        """
        params = []

        if start_date:
            query += " AND event_date >= ?"
            params.append(start_date)
        if end_date:
            query += " AND event_date <= ?"
            params.append(end_date)

        query += """
        GROUP BY strftime('%Y-%m', event_date), severity
        ORDER BY month,
            CASE severity
                WHEN 'Critical' THEN 1
                WHEN 'High' THEN 2
                WHEN 'Medium' THEN 3
                WHEN 'Low' THEN 4
                ELSE 5
            END
        """

        try:
            with self._get_connection() as conn:
                cursor = conn.execute(query, params)
                rows = cursor.fetchall()

                # Organize data by month and severity
                months = []
                severity_data = {}

                for row in rows:
                    if not row['month']:
                        continue

                    month = row['month']
                    severity_raw = row['severity'] or 'Unknown'
                    # Clean up enum strings like 'EventSeverity.HIGH' -> 'High'
                    if severity_raw.startswith('EventSeverity.'):
                        severity = severity_raw.replace('EventSeverity.', '').title()
                    else:
                        severity = severity_raw
                    count = row['event_count']

                    if month not in months:
                        months.append(month)

                    if severity not in severity_data:
                        severity_data[severity] = []

                    # Fill missing months with zeros
                    while len(severity_data[severity]) < len(months):
                        severity_data[severity].append(0)

                    severity_data[severity][-1] = count

                # Ensure all severity levels have data for all months
                for severity in severity_data:
                    while len(severity_data[severity]) < len(months):
                        severity_data[severity].append(0)

                return {
                    'months': months,
                    'data': severity_data
                }
        except Exception as e:
            print(f"Error fetching severity trends: {e}")
            return {'months': [], 'data': {}}

    def get_monthly_records_affected(self, start_date: str = None, end_date: str = None) -> Dict[str, Any]:
        """Get monthly average records affected with confidence intervals."""
        query = """
        SELECT
            strftime('%Y-%m', event_date) as month,
            AVG(CAST(records_affected AS FLOAT)) as avg_records,
            COUNT(DISTINCT deduplicated_event_id) as sample_size,
            MIN(CAST(records_affected AS FLOAT)) as min_records,
            MAX(CAST(records_affected AS FLOAT)) as max_records
        FROM DeduplicatedEvents
        WHERE status = 'Active'
            AND records_affected IS NOT NULL
            AND CAST(records_affected AS INTEGER) > 0
        """
        params = []

        if start_date:
            query += " AND event_date >= ?"
            params.append(start_date)
        if end_date:
            query += " AND event_date <= ?"
            params.append(end_date)

        query += """
        GROUP BY strftime('%Y-%m', event_date)
        ORDER BY month
        """

        try:
            with self._get_connection() as conn:
                cursor = conn.execute(query, params)
                rows = cursor.fetchall()

                months = []
                averages = []
                confidence_intervals = []
                sample_sizes = []

                for row in rows:
                    if not row['month']:
                        continue

                    months.append(row['month'])
                    avg = row['avg_records'] or 0
                    averages.append(avg)
                    sample_sizes.append(row['sample_size'] or 0)

                    # Simple confidence interval (Â±20% for demonstration)
                    margin = avg * 0.2
                    confidence_intervals.append([max(0, avg - margin), avg + margin])

                return {
                    'months': months,
                    'averages': averages,
                    'confidence_intervals': confidence_intervals,
                    'sample_sizes': sample_sizes
                }
        except Exception as e:
            print(f"Error fetching records affected: {e}")
            return {'months': [], 'averages': [], 'confidence_intervals': [], 'sample_sizes': []}

    def get_monthly_event_type_mix(self, start_date: str = None, end_date: str = None) -> Dict[str, Any]:
        """Get monthly event type distribution."""
        query = """
        SELECT
            strftime('%Y-%m', event_date) as month,
            event_type,
            COUNT(DISTINCT deduplicated_event_id) as event_count
        FROM DeduplicatedEvents
        WHERE status = 'Active'
        """
        params = []

        if start_date:
            query += " AND event_date >= ?"
            params.append(start_date)
        if end_date:
            query += " AND event_date <= ?"
            params.append(end_date)

        query += """
        GROUP BY strftime('%Y-%m', event_date), event_type
        ORDER BY month, event_type
        """

        try:
            with self._get_connection() as conn:
                cursor = conn.execute(query, params)
                rows = cursor.fetchall()

                months = []
                event_types = {}

                for row in rows:
                    if not row['month']:
                        continue

                    month = row['month']
                    event_type_raw = row['event_type'] or 'Unknown'
                    # Clean up enum strings like 'CyberEventType.RANSOMWARE' -> 'Ransomware'
                    if event_type_raw.startswith('CyberEventType.'):
                        event_type = event_type_raw.replace('CyberEventType.', '').replace('_', ' ').title()
                    else:
                        event_type = event_type_raw
                    count = row['event_count']

                    if month not in months:
                        months.append(month)

                    if event_type not in event_types:
                        event_types[event_type] = []

                    # Fill missing months with zeros
                    while len(event_types[event_type]) < len(months):
                        event_types[event_type].append(0)

                    event_types[event_type][-1] = count

                # Ensure all event types have data for all months
                for event_type in event_types:
                    while len(event_types[event_type]) < len(months):
                        event_types[event_type].append(0)

                return {
                    'months': months,
                    'types': event_types
                }
        except Exception as e:
            print(f"Error fetching event type mix: {e}")
            return {'months': [], 'types': {}}

    def get_entity_type_distribution(self, start_date: str = None, end_date: str = None) -> Dict[str, Any]:
        """Get entity type distribution."""
        query = """
        SELECT
            COALESCE(e.entity_type, 'Unknown') as entity_type,
            COUNT(DISTINCT de.deduplicated_event_id) as linked_events,
            COUNT(DISTINCT e.entity_id) as unique_entities
        FROM EntitiesV2 e
        INNER JOIN DeduplicatedEventEntities dee ON e.entity_id = dee.entity_id
        INNER JOIN DeduplicatedEvents de ON dee.deduplicated_event_id = de.deduplicated_event_id
        WHERE de.status = 'Active'
        """
        params = []

        if start_date:
            query += " AND de.event_date >= ?"
            params.append(start_date)
        if end_date:
            query += " AND de.event_date <= ?"
            params.append(end_date)

        query += """
        GROUP BY e.entity_type
        ORDER BY linked_events DESC
        """

        try:
            with self._get_connection() as conn:
                cursor = conn.execute(query, params)
                rows = cursor.fetchall()

                types = []
                for row in rows:
                    types.append({
                        'type': row['entity_type'],
                        'events': row['linked_events'],
                        'entities': row['unique_entities']
                    })

                return {'types': types}
        except Exception as e:
            print(f"Error fetching entity distribution: {e}")
            return {'types': []}

    def get_records_affected_histogram(self, start_date: str = None, end_date: str = None) -> Dict[str, Any]:
        """Get histogram of records affected."""
        query = """
        SELECT
            CAST(records_affected AS INTEGER) as records_affected,
            event_type,
            severity,
            COUNT(*) as frequency
        FROM DeduplicatedEvents
        WHERE status = 'Active'
            AND records_affected IS NOT NULL
            AND CAST(records_affected AS INTEGER) > 0
        """
        params = []

        if start_date:
            query += " AND event_date >= ?"
            params.append(start_date)
        if end_date:
            query += " AND event_date <= ?"
            params.append(end_date)

        query += """
        GROUP BY CAST(records_affected AS INTEGER), event_type, severity
        ORDER BY CAST(records_affected AS INTEGER)
        """

        try:
            with self._get_connection() as conn:
                cursor = conn.execute(query, params)
                rows = cursor.fetchall()

                # Create logarithmic bins
                bins = ['1-10', '11-100', '101-1K', '1K-10K', '10K-100K', '100K-1M', '1M+']
                frequencies = [0] * len(bins)

                def get_bin_index(value: int) -> int:
                    if value <= 10:
                        return 0
                    elif value <= 100:
                        return 1
                    elif value <= 1000:
                        return 2
                    elif value <= 10000:
                        return 3
                    elif value <= 100000:
                        return 4
                    elif value <= 1000000:
                        return 5
                    else:
                        return 6

                for row in rows:
                    records = row['records_affected']
                    frequency = row['frequency']
                    bin_idx = get_bin_index(records)
                    frequencies[bin_idx] += frequency

                return {
                    'bins': bins,
                    'frequencies': frequencies
                }
        except Exception as e:
            print(f"Error fetching records histogram: {e}")
            return {'bins': [], 'frequencies': []}


def create_flask_app(db_path: str, debug: bool = False) -> Flask:
    """Create and configure Flask application."""
    app = Flask(__name__)
    CORS(app)  # Enable CORS for API calls

    # Initialize data service
    data_service = DashboardDataService(db_path)

    @app.route('/')
    def dashboard():
        """Serve the main dashboard HTML."""
        return render_template_string(DASHBOARD_HTML_TEMPLATE)

    @app.route('/debug')
    def debug_dashboard():
        """Serve the debug dashboard HTML."""
        with open('debug_dashboard.html', 'r') as f:
            return f.read()

    @app.route('/static/chart.min.js')
    def serve_chartjs():
        """Serve Chart.js locally."""
        try:
            with open('chart.min.js', 'r') as f:
                content = f.read()
            return content, 200, {'Content-Type': 'application/javascript'}
        except FileNotFoundError:
            return "Chart.js not found", 404

    @app.route('/api/v1/dashboard/monthly-event-counts')
    def api_monthly_event_counts():
        """API endpoint for monthly event counts."""
        start_date = request.args.get('start_date')
        end_date = request.args.get('end_date')
        data = data_service.get_monthly_event_counts(start_date, end_date)
        return jsonify(data)

    @app.route('/api/v1/dashboard/monthly-severity-trends')
    def api_monthly_severity_trends():
        """API endpoint for monthly severity trends."""
        start_date = request.args.get('start_date')
        end_date = request.args.get('end_date')
        data = data_service.get_monthly_severity_trends(start_date, end_date)
        return jsonify(data)

    @app.route('/api/v1/dashboard/monthly-records-affected')
    def api_monthly_records_affected():
        """API endpoint for monthly records affected."""
        start_date = request.args.get('start_date')
        end_date = request.args.get('end_date')
        data = data_service.get_monthly_records_affected(start_date, end_date)
        return jsonify(data)

    @app.route('/api/v1/dashboard/monthly-event-type-mix')
    def api_monthly_event_type_mix():
        """API endpoint for monthly event type mix."""
        start_date = request.args.get('start_date')
        end_date = request.args.get('end_date')
        data = data_service.get_monthly_event_type_mix(start_date, end_date)
        return jsonify(data)

    @app.route('/api/v1/dashboard/entity-type-distribution')
    def api_entity_type_distribution():
        """API endpoint for entity type distribution."""
        start_date = request.args.get('start_date')
        end_date = request.args.get('end_date')
        data = data_service.get_entity_type_distribution(start_date, end_date)
        return jsonify(data)

    @app.route('/api/v1/dashboard/records-affected-histogram')
    def api_records_affected_histogram():
        """API endpoint for records affected histogram."""
        start_date = request.args.get('start_date')
        end_date = request.args.get('end_date')
        data = data_service.get_records_affected_histogram(start_date, end_date)
        return jsonify(data)

    return app


# HTML Template for the Dashboard
DASHBOARD_HTML_TEMPLATE = '''
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Australian Cyber Security Events Dashboard</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Chart.js - Local fallback -->
    <script src="/static/chart.min.js"></script>
    <script>
        // Fallback to CDN if local fails
        if (typeof Chart === 'undefined') {
            console.log('Local Chart.js failed, trying CDN...');
            var script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js';
            document.head.appendChild(script);
        }
    </script>

    <!-- Date picker -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

    <style>
        body {
            background-color: #f8f9fa;
        }

        .dashboard-header {
            background: linear-gradient(135deg, #2563eb, #1e40af);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
        }

        .chart-container {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
            height: 400px;
        }

        .chart-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 1rem;
            text-align: center;
        }

        .controls {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 300px;
            color: #6b7280;
        }

        .last-updated {
            color: #6b7280;
            font-size: 0.875rem;
        }

        .export-btn {
            margin-left: 0.5rem;
        }

        @media (max-width: 768px) {
            .chart-container {
                height: 300px;
                padding: 1rem;
            }

            .dashboard-header {
                padding: 1rem 0;
            }

            .chart-title {
                font-size: 1rem;
            }
        }

        /* High contrast mode */
        @media (prefers-contrast: high) {
            .chart-container {
                border: 2px solid #000;
            }
        }

        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="dashboard-header">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-md-8">
                    <h1 class="mb-0">Australian Cyber Security Events Dashboard</h1>
                    <p class="mb-0 last-updated">Last updated: <span id="lastUpdated">Loading...</span></p>
                </div>
                <div class="col-md-4 text-md-end">
                    <button class="btn btn-light export-btn" onclick="exportDashboard()">
                        ðŸ“Š Export PDF
                    </button>
                    <button class="btn btn-light export-btn" onclick="exportData()">
                        ðŸ“‹ Export CSV
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Controls -->
        <div class="controls">
            <div class="row">
                <div class="col-md-6">
                    <label for="dateRange" class="form-label">Date Range:</label>
                    <input type="text" id="dateRange" class="form-control" placeholder="Select date range">
                </div>
                <div class="col-md-6">
                    <div class="d-flex gap-2 align-items-end">
                        <button class="btn btn-primary" onclick="refreshData()">ðŸ”„ Refresh Data</button>
                        <button class="btn btn-outline-primary" onclick="resetFilters()">â†» Reset Filters</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Charts Grid -->
        <div class="row">
            <!-- Monthly Event Trends -->
            <div class="col-lg-6 col-md-12">
                <div class="chart-container">
                    <div class="chart-title">Monthly Trends in Unique Event Count</div>
                    <div class="loading" id="loading1">Loading...</div>
                    <canvas id="monthlyTrendsChart" style="display: none;" aria-label="Monthly event trends chart"></canvas>
                </div>
            </div>

            <!-- Severity Trends -->
            <div class="col-lg-6 col-md-12">
                <div class="chart-container">
                    <div class="chart-title">Monthly Trends in Severity</div>
                    <div class="loading" id="loading2">Loading...</div>
                    <canvas id="severityTrendsChart" style="display: none;" aria-label="Severity trends chart"></canvas>
                </div>
            </div>

            <!-- Records Affected -->
            <div class="col-lg-6 col-md-12">
                <div class="chart-container">
                    <div class="chart-title">Monthly Trends in Average Records Affected</div>
                    <div class="loading" id="loading3">Loading...</div>
                    <canvas id="recordsAffectedChart" style="display: none;" aria-label="Records affected trends chart"></canvas>
                </div>
            </div>

            <!-- Event Type Mix -->
            <div class="col-lg-6 col-md-12">
                <div class="chart-container">
                    <div class="chart-title">Monthly Trends in Event Type Mix</div>
                    <div class="loading" id="loading4">Loading...</div>
                    <canvas id="eventTypeMixChart" style="display: none;" aria-label="Event type mix chart"></canvas>
                </div>
            </div>

            <!-- Entity Type Distribution -->
            <div class="col-lg-6 col-md-12">
                <div class="chart-container">
                    <div class="chart-title">Overall Mix of Entity Types</div>
                    <div class="loading" id="loading5">Loading...</div>
                    <canvas id="entityTypeChart" style="display: none;" aria-label="Entity type distribution chart"></canvas>
                </div>
            </div>

            <!-- Records Histogram -->
            <div class="col-lg-6 col-md-12">
                <div class="chart-container">
                    <div class="chart-title">Records Affected Histogram</div>
                    <div class="loading" id="loading6">Loading...</div>
                    <canvas id="recordsHistogramChart" style="display: none;" aria-label="Records affected histogram chart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Screen reader announcements -->
    <div aria-live="polite" aria-atomic="true" class="sr-only" id="announcements"></div>

    <script>
        // Global variables
        let charts = {};
        let dateRange = null;

        // Color palettes
        const colors = {
            primary: '#2563eb',
            secondary: '#10b981',
            warning: '#f59e0b',
            danger: '#ef4444',
            info: '#06b6d4',
            severity: {
                'Critical': '#dc2626',
                'High': '#ea580c',
                'Medium': '#ca8a04',
                'Low': '#16a34a',
                'Unknown': '#6b7280'
            },
            eventTypes: {
                'Ransomware': '#dc2626',
                'Data Breach': '#2563eb',
                'Phishing': '#7c3aed',
                'Malware': '#ea580c',
                'Other': '#059669'
            }
        };

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Dashboard initializing...');
            console.log('Chart.js available:', typeof Chart !== 'undefined');
            console.log('Chart.js version:', typeof Chart !== 'undefined' ? Chart.version : 'Not loaded');

            initializeDatePicker();
            // Set initial date range
            dateRange = {
                start: '2020-01-01',
                end: new Date().toISOString().split('T')[0]
            };
            console.log('Initial date range set:', dateRange);
            loadAllCharts();
            updateLastUpdated();

            // Set up keyboard navigation
            setupKeyboardNavigation();
        });

        function initializeDatePicker() {
            flatpickr("#dateRange", {
                mode: "range",
                dateFormat: "Y-m-d",
                defaultDate: [
                    new Date('2020-01-01'), // Start from 2020
                    new Date()
                ],
                onChange: function(selectedDates) {
                    if (selectedDates.length === 2) {
                        dateRange = {
                            start: selectedDates[0].toISOString().split('T')[0],
                            end: selectedDates[1].toISOString().split('T')[0]
                        };
                        loadAllCharts();
                    }
                }
            });
        }

        function setupKeyboardNavigation() {
            // Allow keyboard navigation of charts
            document.querySelectorAll('canvas').forEach(canvas => {
                canvas.setAttribute('tabindex', '0');
                canvas.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        // Handle chart interaction
                        announce(`Interacting with ${canvas.getAttribute('aria-label')}`);
                    }
                });
            });
        }

        function announce(message) {
            const announcements = document.getElementById('announcements');
            announcements.textContent = message;
        }

        async function loadAllCharts() {
            console.log('loadAllCharts called');
            try {
                console.log('Loading monthly trends...');
                await loadMonthlyTrends();
                console.log('Loading severity trends...');
                await loadSeverityTrends();
                console.log('Loading records affected...');
                await loadRecordsAffected();
                console.log('Loading event type mix...');
                await loadEventTypeMix();
                console.log('Loading entity types...');
                await loadEntityTypes();
                console.log('Loading records histogram...');
                await loadRecordsHistogram();
                announce('All charts loaded successfully');
            } catch (error) {
                console.error('Error loading charts:', error);
                announce('Error loading some charts');
            }
        }

        function buildApiUrl(endpoint) {
            let url = `/api/v1/dashboard/${endpoint}`;
            if (dateRange) {
                url += `?start_date=${dateRange.start}&end_date=${dateRange.end}`;
            }
            console.log('Building API URL:', url);
            return url;
        }

        async function loadMonthlyTrends() {
            console.log('loadMonthlyTrends starting...');
            try {
                const url = buildApiUrl('monthly-event-counts');
                console.log('Fetching from URL:', url);
                const response = await fetch(url);
                console.log('Response received:', response.status, response.statusText);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                console.log('Data received:', data);

                const canvas = document.getElementById('monthlyTrendsChart');
                console.log('Canvas element found:', canvas);
                const ctx = canvas.getContext('2d');
                console.log('Canvas context:', ctx);

                if (charts.monthlyTrends) {
                    console.log('Destroying existing chart');
                    charts.monthlyTrends.destroy();
                }

                console.log('Creating new chart with data:', data);

                // Check if Chart.js is available
                if (typeof Chart === 'undefined') {
                    throw new Error('Chart.js library not loaded');
                }

                charts.monthlyTrends = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: data.months,
                        datasets: [{
                            label: 'Unique Events',
                            data: data.counts,
                            borderColor: colors.primary,
                            backgroundColor: colors.primary + '20',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    footer: function(tooltipItems) {
                                        return `Total: ${data.total_events} events`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Events'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Month'
                                }
                            }
                        }
                    }
                });

                console.log('Chart created successfully:', charts.monthlyTrends);
                hideLoading('loading1', 'monthlyTrendsChart');
            } catch (error) {
                console.error('Error loading monthly trends:', error);

                // If Chart.js failed but we have data, show a simple data table
                if (error.message.includes('Chart') && typeof data !== 'undefined' && data.months) {
                    const loadingEl = document.getElementById('loading1');
                    loadingEl.innerHTML = `
                        <div style="font-size: 12px;">
                            <strong>Data Loaded Successfully (Chart.js unavailable):</strong><br>
                            <strong>Total Events:</strong> ${data.total_events}<br>
                            <strong>Months:</strong> ${data.months.join(', ')}<br>
                            <strong>Counts:</strong> ${data.counts.join(', ')}
                        </div>
                    `;
                } else {
                    showError('loading1', `Failed to load monthly trends: ${error.message}`);
                }
            }
        }

        async function loadSeverityTrends() {
            try {
                const response = await fetch(buildApiUrl('monthly-severity-trends'));
                const data = await response.json();

                const ctx = document.getElementById('severityTrendsChart').getContext('2d');

                if (charts.severityTrends) {
                    charts.severityTrends.destroy();
                }

                const datasets = Object.keys(data.data).map(severity => ({
                    label: severity,
                    data: data.data[severity],
                    backgroundColor: colors.severity[severity] || '#6b7280',
                    borderColor: colors.severity[severity] || '#6b7280'
                }));

                charts.severityTrends = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: data.months,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top'
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: 'Month'
                                }
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Events'
                                }
                            }
                        }
                    }
                });

                hideLoading('loading2', 'severityTrendsChart');
            } catch (error) {
                console.error('Error loading severity trends:', error);
                showError('loading2', 'Failed to load severity trends');
            }
        }

        async function loadRecordsAffected() {
            try {
                const response = await fetch(buildApiUrl('monthly-records-affected'));
                const data = await response.json();

                const ctx = document.getElementById('recordsAffectedChart').getContext('2d');

                if (charts.recordsAffected) {
                    charts.recordsAffected.destroy();
                }

                charts.recordsAffected = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: data.months,
                        datasets: [{
                            label: 'Average Records Affected',
                            data: data.averages,
                            borderColor: colors.secondary,
                            backgroundColor: colors.secondary + '20',
                            fill: false,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    footer: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return `Sample size: ${data.sample_sizes[index]} events`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'logarithmic',
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Records Affected (log scale)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Month'
                                }
                            }
                        }
                    }
                });

                hideLoading('loading3', 'recordsAffectedChart');
            } catch (error) {
                console.error('Error loading records affected:', error);
                showError('loading3', 'Failed to load records affected data');
            }
        }

        async function loadEventTypeMix() {
            try {
                const response = await fetch(buildApiUrl('monthly-event-type-mix'));
                const data = await response.json();

                const ctx = document.getElementById('eventTypeMixChart').getContext('2d');

                if (charts.eventTypeMix) {
                    charts.eventTypeMix.destroy();
                }

                const datasets = Object.keys(data.types).map((eventType, index) => ({
                    label: eventType,
                    data: data.types[eventType],
                    backgroundColor: colors.eventTypes[eventType] || `hsl(${index * 60}, 70%, 50%)`,
                    borderColor: colors.eventTypes[eventType] || `hsl(${index * 60}, 70%, 40%)`
                }));

                charts.eventTypeMix = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: data.months,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top'
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: 'Month'
                                }
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Events'
                                }
                            }
                        }
                    }
                });

                hideLoading('loading4', 'eventTypeMixChart');
            } catch (error) {
                console.error('Error loading event type mix:', error);
                showError('loading4', 'Failed to load event type mix');
            }
        }

        async function loadEntityTypes() {
            try {
                const response = await fetch(buildApiUrl('entity-type-distribution'));
                const data = await response.json();

                const ctx = document.getElementById('entityTypeChart').getContext('2d');

                if (charts.entityTypes) {
                    charts.entityTypes.destroy();
                }

                charts.entityTypes = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: data.types.map(t => t.type),
                        datasets: [{
                            data: data.types.map(t => t.events),
                            backgroundColor: data.types.map((_, index) =>
                                `hsl(${index * 360 / data.types.length}, 70%, 50%)`
                            )
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const type = data.types[context.dataIndex];
                                        return `${type.type}: ${type.events} events (${type.entities} entities)`;
                                    }
                                }
                            }
                        }
                    }
                });

                hideLoading('loading5', 'entityTypeChart');
            } catch (error) {
                console.error('Error loading entity types:', error);
                showError('loading5', 'Failed to load entity type distribution');
            }
        }

        async function loadRecordsHistogram() {
            try {
                const response = await fetch(buildApiUrl('records-affected-histogram'));
                const data = await response.json();

                const ctx = document.getElementById('recordsHistogramChart').getContext('2d');

                if (charts.recordsHistogram) {
                    charts.recordsHistogram.destroy();
                }

                charts.recordsHistogram = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: data.bins,
                        datasets: [{
                            label: 'Frequency',
                            data: data.frequencies,
                            backgroundColor: colors.info + '80',
                            borderColor: colors.info,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Events'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Records Affected (ranges)'
                                }
                            }
                        }
                    }
                });

                hideLoading('loading6', 'recordsHistogramChart');
            } catch (error) {
                console.error('Error loading records histogram:', error);
                showError('loading6', 'Failed to load records histogram');
            }
        }

        function hideLoading(loadingId, chartId) {
            const loadingEl = document.getElementById(loadingId);
            const chartEl = document.getElementById(chartId);
            console.log('Hiding loading for:', loadingId, 'Showing chart:', chartId);
            loadingEl.style.display = 'none';
            chartEl.style.display = 'block';
        }

        function showError(loadingId, message) {
            const loadingElement = document.getElementById(loadingId);
            loadingElement.textContent = message;
            loadingElement.style.color = '#ef4444';
        }

        function updateLastUpdated() {
            document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
        }

        function refreshData() {
            announce('Refreshing dashboard data');
            // Show loading indicators
            document.querySelectorAll('.loading').forEach(el => {
                el.style.display = 'flex';
                el.textContent = 'Loading...';
                el.style.color = '#6b7280';
            });
            document.querySelectorAll('canvas').forEach(el => {
                el.style.display = 'none';
            });

            loadAllCharts();
            updateLastUpdated();
        }

        function resetFilters() {
            dateRange = null;
            document.getElementById('dateRange').value = '';
            refreshData();
            announce('Filters reset');
        }

        function exportDashboard() {
            announce('Exporting dashboard to PDF');
            // Implementation would use libraries like jsPDF
            alert('PDF export functionality would be implemented here');
        }

        function exportData() {
            announce('Exporting data to CSV');
            // Implementation would aggregate all chart data
            alert('CSV export functionality would be implemented here');
        }
    </script>
</body>
</html>
'''


def main():
    """Main function to run the dashboard generator."""
    parser = argparse.ArgumentParser(
        description='Generate Australian Cyber Events Dashboard',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument('--port', type=int, default=5000,
                        help='Port to run the dashboard server on (default: 5000)')
    parser.add_argument('--debug', action='store_true',
                        help='Run in debug mode')
    parser.add_argument('--db-path', default='instance/cyber_events.db',
                        help='Path to the SQLite database file')
    parser.add_argument('--host', default='127.0.0.1',
                        help='Host to run the server on (default: 127.0.0.1)')

    args = parser.parse_args()

    # Check if database exists
    if not os.path.exists(args.db_path):
        print(f"Error: Database file not found at {args.db_path}")
        print("Please ensure the database exists and contains the required tables.")
        sys.exit(1)

    # Verify database schema
    try:
        data_service = DashboardDataService(args.db_path)
        # Test a simple query to verify schema
        with data_service._get_connection() as conn:
            cursor = conn.execute("SELECT name FROM sqlite_master WHERE type='table'")
            tables = [row[0] for row in cursor.fetchall()]

            required_tables = ['DeduplicatedEvents', 'EntitiesV2', 'DeduplicatedEventEntities']
            missing_tables = [table for table in required_tables if table not in tables]

            if missing_tables:
                print(f"Error: Missing required database tables: {missing_tables}")
                print("Please run the database migration script first.")
                sys.exit(1)

    except Exception as e:
        print(f"Error connecting to database: {e}")
        sys.exit(1)

    # Create Flask app
    app = create_flask_app(args.db_path, args.debug)

    print(f"Starting Australian Cyber Events Dashboard...")
    print(f"Database: {args.db_path}")
    print(f"Server: http://{args.host}:{args.port}")
    print(f"Debug mode: {args.debug}")
    print("\nPress Ctrl+C to stop the server")

    try:
        app.run(host=args.host, port=args.port, debug=args.debug)
    except KeyboardInterrupt:
        print("\nDashboard server stopped.")


if __name__ == '__main__':
    main()